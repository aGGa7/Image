// Вставьте сюда финальное содержимое файла MedianFilterTask.cs

using System.Collections.Generic;

namespace Recognizer
{
    internal static class MedianFilterTask
    {
        /* 
		 * Для борьбы с пиксельным шумом, подобным тому, что на изображении,
		 * обычно применяют медианный фильтр, в котором цвет каждого пикселя, 
		 * заменяется на медиану всех цветов в некоторой окрестности пикселя.
		 * https://en.wikipedia.org/wiki/Median_filter
		 * 
		 * Используйте окно размером 3х3 для не граничных пикселей,
		 * Окно размером 2х2 для угловых и 3х2 или 2х3 для граничных.
		 */
        public static double[,] MedianFilter(double[,] original)
        {
            int lenghtX = original.GetLength(0);
            int lenghtY = original.GetLength(1);
            double[,] filterimage = new double[lenghtX, lenghtY]; //двумерный массив в который будет записываться результат
            List<double> window = new List<double>(); //окно для простоты реализовано просто как коллекция
            for (int x = 0; x < lenghtX; x++) //основной цикл прохода по всему исходному изображению
                for (int y = 0; y < lenghtY; y++)
                {
                    /*
                     * Пояснение по блоку if else для обхода изображения по краям
                     * условия порверяют находимся ли мы в углу изображения или на краю
                     * 4 блока проверяют 4 угла и 4 стороны, блоки возможно получились разбросаны хаотично
                     * в каждом блоке реализовал свое окно
                     * можно считать что координата У здесь растет сверху вниз (как принято в графике) но это не точно)
                     * также логику можно улучшить если для каждого случая не писать отдельный цикл
                     * а сделать один цикл в который подается окно, размер которого зависит от того на какой части изображения 
                     * мы находимся. Но есть нюанс - чтобы обойти выход за массив вот здесь original[x + xw - 1, y + yw - 1]
                     * окно нужно передавать с отрицательными значениями
                     * для противоположной стороны. или сделать этот как то по другому
                     */
                    if (lenghtX < 2 && lenghtY < 2) //на случай если на вход подается изображение 1х1
                        return original;
                    else if (y == 0 && x < lenghtX - 1) // если мы находимся в углу (левый верхний) или на верхнем краю изображения
                    {
                        for (int xw = 0; xw < (lenghtX < 2 ? 1 : x == 0 ? 2 : 3); xw++) //цикл для заполнения значений массива окна, если в углу 2 прохода(чтобы не вылезти за пределы массива), если на крайней линии то 3 прохода
                            for (int yw = 0; yw < (lenghtY > 1 ? 2 : 1); yw++) //также заодно проверяется сколько строк/столбцов в картинке(например картинка может быть 3х1)
                            {
                                if (x == 0) // если в углу используем схему окна 2х2 (по заданию)
                                    window.Add(original[x + xw, y + yw]);
                                else //иначе считаем что на краю, размер окна 2х3 (по заданию)
                                    window.Add(original[x + xw - 1, y + yw]);
                            }
                    }
                    else if (x == lenghtX - 1 && y < lenghtY - 1) //если мы находимся в углу (правый верхний) или на правом краю изображения
                    {
                        for (int xw = 0; xw < (lenghtX > 1 ? 2 : 1); xw++)
                            for (int yw = 0; yw < (lenghtY < 2 ? 1 : y == 0 ? 2 : 3); yw++)
                            {
                                if (y == 0)
                                    window.Add(original[x - xw, y + yw]);
                                else
                                    window.Add(original[x - xw, y + yw - 1]);
                            }
                    }
                    else if (y == lenghtY - 1 && x > 0)//если мы находимся в углу (правый нижемй) или на нижнем краю изображения
                    {
                        for (int xw = 0; xw < (lenghtX < 2 ? 1 : x == lenghtX - 1 ? 2 : 3); xw++) //цикл для заполнения значений массива окна
                            for (int yw = 0; yw < (lenghtY > 1 ? 2 : 1); yw++)
                            {
                                if (x == lenghtX - 1)
                                    window.Add(original[x - xw, y - yw]);
                                else
                                    window.Add(original[x - xw + 1, y - yw]);
                            }
                    }
                    else if (x == 0 && y > 0)//если мы находимся в углу (левый нижний) или на левом краю изображения
                    {
                        for (int xw = 0; xw < (lenghtX > 1 ? 2 : 1); xw++) //цикл для заполнения значений массива окна
                            for (int yw = 0; yw < (lenghtY < 2 ? 1 : y == lenghtY - 1 ? 2 : 3); yw++)
                            {
                                if (y == lenghtY - 1)
                                    window.Add(original[x + xw, y - yw]);
                                else
                                    window.Add(original[x + xw, y - yw + 1]);
                            }
                    }
                    else //логика для центральных пикселей
                    {
                        for (int xw = 0; xw < 3; xw++) //цикл для заполнения значений массива окна
                            for (int yw = 0; yw < 3; yw++)
                                window.Add(original[x + xw - 1, y + yw - 1]); //заполняем массив окна
                    }
                    window.Sort(); // сортируем значения в окне т.к. нам нужны значения "по центру"
                    if (window.Count % 2 != 0) //если в окне нечетное количество значений то просто
                        filterimage[x, y] = window[window.Count / 2]; // выберу значение оказавшееся в центре
                    else //если четное
                        filterimage[x, y] = (window[(window.Count / 2) - 1] + window[window.Count / 2]) / 2; //тогда вычисляю среднеарифметическое двух значений у центра
                    window.Clear();
                }
            return filterimage;
        }

    }
}
